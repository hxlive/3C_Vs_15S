<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>三炮大战十五兵</title>
  <style>
    body {
      background-color: #e5e7eb;
      font-family: sans-serif;
    }
    canvas {
      border: 2px solid #4B5EAA;
      background-color: #F5F5DC;
    }
    .游戏容器 {
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
    }
    h1 {
      font-size: 36px;
      font-weight: 800;
      color: #4f46e5;
      margin-bottom: 24px;
    }
    #游戏状态 {
      margin-top: 24px;
      font-size: 20px;
      color: #1f2937;
      font-weight: 600;
    }
    #重置按钮 {
      margin-top: 24px;
      background-color: #4f46e5;
      color: white;
      padding: 12px 24px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      border: none;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    #重置按钮:hover {
      background-color: #4338ca;
    }
    @media (max-width: 600px) {
      canvas {
        width: 300px;
        height: 300px;
      }
    }
  </style>
</head>
<body>
  <div class="游戏容器">
    <h1>三炮大战十五兵</h1>
    <canvas id="游戏画布" width="500" height="500"></canvas>
    <div id="游戏状态"></div>
    <button id="重置按钮">重新开始</button>
  </div>
  <script>
    const 画布 = document.getElementById('游戏画布');
    const 上下文 = 画布.getContext('2d');
    const 状态 = document.getElementById('游戏状态');
    const 重置按钮 = document.getElementById('重置按钮');

    const 网格大小 = 5;
    let 格子大小 = 画布.width / 网格大小; // 使用 let 允许重新赋值
    const 黑棋 = '#1a1a1a';
    const 蓝棋 = '#87CEEB';

    class 棋盘 {
      constructor() {
        this.网格 = Array(网格大小 * 网格大小).fill(null);
        this.回合 = 蓝棋; // 蓝棋先行
        this.选中棋子 = null;
        this.吃掉黑棋数 = 0;
      }

      初始化() {
        // 初始化黑棋（1-15，0-based: 0-14）
        for (let i = 0; i < 15; i++) {
          this.网格[i] = 黑棋;
        }
        // 初始化蓝棋（22-24，0-based: 21-23）
        for (let i = 21; i <= 23; i++) {
          this.网格[i] = 蓝棋;
        }
        this.吃掉黑棋数 = 0;
        this.回合 = 蓝棋; // 蓝棋先行
        this.选中棋子 = null;
      }

      获取合法移动(pos) {
        const 移动 = [];
        const 方向 = [
          { 行变化: -1, 列变化: 0 }, // 上
          { 行变化: 1, 列变化: 0 },  // 下
          { 行变化: 0, 列变化: -1 }, // 左
          { 行变化: 0, 列变化: 1 }   // 右
        ];
        const 行 = Math.floor(pos / 网格大小);
        const 列 = pos % 网格大小;

        // 普通移动
        for (const { 行变化, 列变化 } of 方向) {
          const 新行 = 行 + 行变化;
          const 新列 = 列 + 列变化;
          if (this.是否合法位置(新行, 新列) && this.网格[新行 * 网格大小 + 新列] === null) {
            移动.push(新行 * 网格大小 + 新列);
          }
        }

        // 蓝棋吃子
        if (this.网格[pos] === 蓝棋) {
          for (const { 行变化, 列变化 } of 方向) {
            const 中间行 = 行 + 行变化;
            const 中间列 = 列 + 列变化;
            const 目标行 = 行 + 2 * 行变化;
            const 目标列 = 列 + 2 * 列变化;
            if (
              this.是否合法位置(中间行, 中间列) &&
              this.是否合法位置(目标行, 目标列) &&
              this.网格[中间行 * 网格大小 + 中间列] === null &&
              this.网格[目标行 * 网格大小 + 目标列] === 黑棋
            ) {
              移动.push(目标行 * 网格大小 + 目标列); // 跳到黑棋位置
            }
          }
        }

        return 移动;
      }

      是否合法位置(行, 列) {
        return 行 >= 0 && 行 < 网格大小 && 列 >= 0 && 列 < 网格大小;
      }

      移动棋子(从, 到) {
        const 棋子 = this.网格[从];
        this.网格[从] = null;
        const 是否吃子 = this.网格[到] === 黑棋; // 检查是否跳到黑棋位置
        this.网格[到] = 棋子;

        // 吃子时增加计数
        if (棋子 === 蓝棋 && 是否吃子) {
          this.吃掉黑棋数++;
        }

        this.回合 = this.回合 === 黑棋 ? 蓝棋 : 黑棋;
        return { 从, 到, 是否吃子 }; // 返回移动信息用于动画
      }

      检查胜负() {
        if (this.吃掉黑棋数 >= 12) {
          return '蓝棋获胜！吃掉12个或更多黑棋';
        }
        if (this.回合 === 蓝棋) {
          let 有移动 = false;
          for (let i = 0; i < this.网格.length; i++) {
            if (this.网格[i] === 蓝棋 && this.获取合法移动(i).length > 0) {
              有移动 = true;
              break;
            }
          }
          if (!有移动) {
            return '黑棋获胜！所有蓝棋被困';
          }
        }
        return null;
      }
    }

    class 渲染器 {
      绘制棋盘(棋盘) {
        上下文.clearRect(0, 0, 画布.width, 画布.height);

        // 绘制网格
        上下文.strokeStyle = '#4B5EAA';
        上下文.lineWidth = 1;
        for (let i = 0; i <= 网格大小; i++) {
          上下文.beginPath();
          上下文.moveTo(i * 格子大小, 0);
          上下文.lineTo(i * 格子大小, 网格大小 * 格子大小);
          上下文.stroke();
          上下文.beginPath();
          上下文.moveTo(0, i * 格子大小);
          上下文.lineTo(网格大小 * 格子大小, i * 格子大小);
          上下文.stroke();
        }

        // 绘制格子编号（1-25）
        上下文.fillStyle = '#666666';
        上下文.font = `${格子大小 / 7}px Arial`; // 动态调整字体大小
        上下文.textAlign = 'right';
        上下文.textBaseline = 'bottom';
        for (let i = 0; i < 网格大小 * 网格大小; i++) {
          const 行 = Math.floor(i / 网格大小);
          const 列 = i % 网格大小;
          上下文.fillText(i + 1, 列 * 格子大小 + 格子大小 - 5, 行 * 格子大小 + 格子大小 - 5);
        }

        // 绘制棋子
        for (let i = 0; i < 棋盘.网格.length; i++) {
          if (棋盘.网格[i]) {
            const 行 = Math.floor(i / 网格大小);
            const 列 = i % 网格大小;
            上下文.fillStyle = 棋盘.网格[i];
            上下文.beginPath();
            上下文.arc(
              列 * 格子大小 + 格子大小 / 2,
              行 * 格子大小 + 格子大小 / 2,
              格子大小 / 3,
              0,
              2 * Math.PI
            );
            上下文.fill();
            上下文.strokeStyle = '#000000';
            上下文.lineWidth = 1;
            上下文.stroke(); // 添加边框提升清晰度
          }
        }

        // 高亮选中棋子
        if (棋盘.选中棋子 !== null) {
          const 行 = Math.floor(棋盘.选中棋子 / 网格大小);
          const 列 = 棋盘.选中棋子 % 网格大小;
          上下文.strokeStyle = '#FFFF00';
          上下文.lineWidth = 5;
          上下文.beginPath();
          上下文.arc(
            列 * 格子大小 + 格子大小 / 2,
            行 * 格子大小 + 格子大小 / 2,
            格子大小 / 3,
            0,
            2 * Math.PI
          );
          上下文.stroke();

          // 高亮合法移动
          const 移动 = 棋盘.获取合法移动(棋盘.选中棋子);
          上下文.fillStyle = 'rgba(50, 205, 50, 0.4)';
          for (const 移动位置 of 移动) {
            const 移动行 = Math.floor(移动位置 / 网格大小);
            const 移动列 = 移动位置 % 网格大小;
            上下文.fillRect(移动列 * 格子大小, 移动行 * 格子大小, 格子大小, 格子大小);
          }
        }

        // 更新状态
        状态.textContent = `轮到：${棋盘.回合 === 黑棋 ? '黑棋' : '蓝棋'} | 吃掉黑棋数：${棋盘.吃掉黑棋数}`;
      }

      动画移动(棋盘, 从, 到, 是否吃子, 回调) {
        if (!是否吃子) {
          this.绘制棋盘(棋盘);
          回调();
          return;
        }

        const 从行 = Math.floor(从 / 网格大小);
        const 从列 = 从 % 网格大小;
        const 到行 = Math.floor(到 / 网格大小);
        const 到列 = 到 % 网格大小;
        let t = 0;
        const 持续时间 = 300; // 动画时长（毫秒）
        const 开始X = 从列 * 格子大小 + 格子大小 / 2;
        const 开始Y = 从行 * 格子大小 + 格子大小 / 2;
        const 结束X = 到列 * 格子大小 + 格子大小 / 2;
        const 结束Y = 到行 * 格子大小 + 格子大小 / 2;

        const 动画 = () => {
          t += 16 / 持续时间; // 约60fps
          if (t >= 1) {
            this.绘制棋盘(棋盘);
            回调();
            return;
          }

          this.绘制棋盘(棋盘);
          上下文.fillStyle = 蓝棋;
          上下文.beginPath();
          const x = 开始X + (结束X - 开始X) * t;
          const y = 开始Y + (结束Y - 开始Y) * t;
          上下文.arc(x, y, 格子大小 / 3, 0, 2 * Math.PI);
          上下文.fill();
          上下文.strokeStyle = '#000000';
          上下文.lineWidth = 1;
          上下文.stroke();

          requestAnimationFrame(动画);
        };

        requestAnimationFrame(动画);
      }
    }

    class 游戏 {
      constructor() {
        this.棋盘 = new 棋盘();
        this.渲染器 = new 渲染器();
        this.棋盘.初始化();
        this.渲染器.绘制棋盘(this.棋盘);
      }

      处理点击(x, y) {
        const 行 = Math.floor(y / 格子大小);
        const 列 = Math.floor(x / 格子大小);
        const 位置 = 行 * 网格大小 + 列;

        if (this.棋盘.选中棋子 === null) {
          if (this.棋盘.网格[位置] === this.棋盘.回合) {
            this.棋盘.选中棋子 = 位置;
          }
        } else {
          const 移动 = this.棋盘.获取合法移动(this.棋盘.选中棋子);
          if (移动.includes(位置)) {
            const { 从, 到, 是否吃子 } = this.棋盘.移动棋子(this.棋盘.选中棋子, 位置);
            this.渲染器.动画移动(this.棋盘, 从, 到, 是否吃子, () => {
              this.棋盘.选中棋子 = null;
              const 结果 = this.棋盘.检查胜负();
              if (结果) {
                状态.textContent = 结果;
                画布.removeEventListener('click', this.点击处理器);
              }
              this.渲染器.绘制棋盘(this.棋盘);
            });
            return;
          } else {
            this.棋盘.选中棋子 = null;
          }
        }

        this.渲染器.绘制棋盘(this.棋盘);
      }

      重置() {
        this.棋盘.初始化();
        画布.addEventListener('click', this.点击处理器);
        this.渲染器.绘制棋盘(this.棋盘);
      }
    }

    const 游戏实例 = new 游戏();
    游戏实例.点击处理器 = (e) => {
      const 矩形 = 画布.getBoundingClientRect();
      const x = e.clientX - 矩形.left;
      const y = e.clientY - 矩形.top;
      游戏实例.处理点击(x, y);
    };
    画布.addEventListener('click', 游戏实例.点击处理器);
    重置按钮.addEventListener('click', () => 游戏实例.重置());

    // 响应式画布尺寸
    function 调整画布大小() {
      if (window.innerWidth < 600) {
        画布.width = 300;
        画布.height = 300;
      } else {
        画布.width = 500;
        画布.height = 500;
      }
      格子大小 = 画布.width / 网格大小; // 更新格子大小
      游戏实例.渲染器.绘制棋盘(游戏实例.棋盘);
    }
    window.addEventListener('resize', 调整画布大小);
    调整画布大小();
  </script>
</body>
</html>