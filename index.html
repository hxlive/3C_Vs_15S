<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>三炮大战十五兵-hxlive版</title>
  <style>
    body {
      background: linear-gradient(to bottom, #e5e7eb, #F5F5DC);
      font-family: sans-serif;
      min-height: 100vh;
    }
    canvas {
      border: 2px solid #4B5EAA;
      background-color: #F5F5DC;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
    }
    .游戏容器 {
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
    }
    h1 {
      font-size: 36px;
      font-weight: 800;
      color: #4f46e5;
      margin-bottom: 24px;
    }
    #游戏状态 {
      margin-top: 24px;
      font-size: 20px;
      font-weight: 600;
      color: #60A5FA;
    }
    .回合-白棋 {
      color: #FFFFFF;
      text-shadow: 0 0 2px #000000;
    }
    .回合-黑棋 {
      color: #1a1a1a;
    }
    .胜负提示 {
      font-weight: 700;
    }
    .按钮组 {
      margin-top: 16px;
      display: flex;
      gap: 16px;
    }
    button {
      background-color: #4f46e5;
      color: white;
      padding: 12px 24px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      border: none;
      cursor: pointer;
      transition: transform 0.2s, background-color 0.3s;
    }
    button:hover {
      background-color: #4338ca;
      transform: scale(1.05);
    }
    button:disabled {
      background-color: #9ca3af;
      cursor: not-allowed;
      transform: none;
    }
    @media (max-width: 600px) {
      canvas {
        width: 300px;
        height: 300px;
      }
    }
    @media (min-width: 600px) and (max-width: 800px) {
      canvas {
        width: 400px;
        height: 400px;
      }
    }
  </style>
</head>
<body>
  <div class="游戏容器">
    <h1>三炮大战十五兵</h1>
    <canvas id="游戏画布" width="500" height="500"></canvas>
    <div id="游戏状态"></div>
    <div class="按钮组">
      <button id="执白棋按钮">执白棋</button>
      <button id="执黑棋按钮">执黑棋</button>
      <button id="重置按钮">重新开始</button>
    </div>
  </div>
  <script>
    const 画布 = document.getElementById('游戏画布');
    const 上下文 = 画布.getContext('2d');
    const 状态 = document.getElementById('游戏状态');
    const 重置按钮 = document.getElementById('重置按钮');
    const 执白棋按钮 = document.getElementById('执白棋按钮');
    const 执黑棋按钮 = document.getElementById('执黑棋按钮');

    const 网格大小 = 5;
    let 格子大小 = 画布.width / 网格大小;
    const 黑棋 = '#333333'; // 柔和深灰黑
    const 白棋 = '#F5F5F5'; // 柔和白

    // 音效
    const 音效环境 = new (window.AudioContext || window.webkitAudioContext)();
    function 播放音效(频率, 持续时间) {
      const 振荡器 = 音效环境.createOscillator();
      const 增益节点 = 音效环境.createGain();
      振荡器.connect(增益节点);
      增益节点.connect(音效环境.destination);
      振荡器.type = 'sine';
      振荡器.frequency.setValueAtTime(频率, 音效环境.currentTime);
      增益节点.gain.setValueAtTime(0.5, 音效环境.currentTime);
      振荡器.start();
      振荡器.stop(音效环境.currentTime + 持续时间);
    }

    class 棋盘 {
      constructor() {
        this.网格 = Array(网格大小 * 网格大小).fill(null);
        this.回合 = 白棋;
        this.选中棋子 = null;
        this.吃掉黑棋数 = 0;
        this.最后移动 = null;
      }

      初始化() {
        this.网格.fill(null);
        for (let i = 0; i < 15; i++) {
          this.网格[i] = 黑棋;
        }
        for (let i = 21; i <= 23; i++) {
          this.网格[i] = 白棋;
        }
        this.吃掉黑棋数 = 0;
        this.回合 = 白棋;
        this.选中棋子 = null;
        this.最后移动 = null;
      }

      获取合法移动(pos) {
        const 移动 = [];
        const 方向 = [
          { 行变化: -1, 列变化: 0 }, // 上
          { 行变化: 1, 列变化: 0 },  // 下
          { 行变化: 0, 列变化: -1 }, // 左
          { 行变化: 0, 列变化: 1 }   // 右
        ];
        const 行 = Math.floor(pos / 网格大小);
        const 列 = pos % 网格大小;

        // 普通移动
        for (const { 行变化, 列变化 } of 方向) {
          const 新行 = 行 + 行变化;
          const 新列 = 列 + 列变化;
          if (this.是否合法位置(新行, 新列) && this.网格[新行 * 网格大小 + 新列] === null) {
            移动.push(新行 * 网格大小 + 新列);
          }
        }

        // 白棋吃子
        if (this.网格[pos] === 白棋) {
          for (const { 行变化, 列变化 } of 方向) {
            const 中间行 = 行 + 行变化;
            const 中间列 = 列 + 列变化;
            const 目标行 = 行 + 2 * 行变化;
            const 目标列 = 列 + 2 * 列变化;
            if (
              this.是否合法位置(中间行, 中间列) &&
              this.是否合法位置(目标行, 目标列) &&
              this.网格[中间行 * 网格大小 + 中间列] === null &&
              this.网格[目标行 * 网格大小 + 目标列] === 黑棋
            ) {
              移动.push(目标行 * 网格大小 + 目标列);
            }
          }
        }

        return 移动;
      }

      是否合法位置(行, 列) {
        return 行 >= 0 && 行 < 网格大小 && 列 >= 0 && 列 < 网格大小;
      }

      移动棋子(从, 到) {
        if (!this.网格[从] || (this.网格[到] && this.网格[到] !== 黑棋)) {
          return null;
        }
        const 棋子 = this.网格[从];
        this.网格[从] = null;
        const 是否吃子 = this.网格[到] === 黑棋;
        this.网格[到] = 棋子;

        if (棋子 === 白棋 && 是否吃子) {
          this.吃掉黑棋数++;
        }

        this.回合 = this.回合 === 黑棋 ? 白棋 : 黑棋;
        this.最后移动 = { 从, 到 };
        return { 从, 到, 是否吃子 };
      }

      检查胜负() {
        if (this.吃掉黑棋数 >= 12) {
          return '白棋获胜！吃掉12个或更多黑棋';
        }
        if (this.回合 === 白棋) {
          let 有移动 = false;
          for (let i = 0; i < this.网格.length; i++) {
            if (this.网格[i] === 白棋 && this.获取合法移动(i).length > 0) {
              有移动 = true;
              break;
            }
          }
          if (!有移动) {
            return '黑棋获胜！所有白棋被困';
          }
        }
        return null;
      }

      复制() {
        const 新棋盘 = new 棋盘();
        新棋盘.网格 = [...this.网格];
        新棋盘.回合 = this.回合;
        新棋盘.吃掉黑棋数 = this.吃掉黑棋数;
        新棋盘.最后移动 = this.最后移动;
        return 新棋盘;
      }
    }

    class AI {
      constructor(棋盘) {
        this.棋盘 = 棋盘;
      }

      评估() {
        if (this.棋盘.吃掉黑棋数 >= 12) {
          return 10000;
        }
        let 白棋移动数 = 0;
        let 白棋边缘得分 = 0;
        let 白棋位置 = [];
        let 黑棋靠近白棋得分 = 0;
        for (let i = 0; i < this.棋盘.网格.length; i++) {
          if (this.棋盘.网格[i] === 白棋) {
            白棋移动数 += this.棋盘.获取合法移动(i).length;
            const 行 = Math.floor(i / 网格大小);
            const 列 = i % 网格大小;
            白棋位置.push({ 行, 列 });
            const 边缘距离 = Math.min(行, 网格大小 - 1 - 行, 列, 网格大小 - 1 - 列);
            白棋边缘得分 += 边缘距离 === 0 ? 10 : 边缘距离 === 1 ? 5 : 0;
          }
        }
        if (白棋移动数 === 0 && this.棋盘.回合 === 白棋) {
          return -10000;
        }

        if (this.棋盘.回合 === 黑棋) {
          for (let i = 0; i < this.棋盘.网格.length; i++) {
            if (this.棋盘.网格[i] === 黑棋) {
              const 行 = Math.floor(i / 网格大小);
              const 列 = i % 网格大小;
              let 最小距离 = Infinity;
              for (const { 行: 白行, 列: 白列 } of 白棋位置) {
                const 距离 = Math.abs(行 - 白行) + Math.abs(列 - 白列);
                最小距离 = Math.min(最小距离, 距离);
              }
              黑棋靠近白棋得分 += 最小距离 <= 2 ? 5 : 0;
            }
          }
        }

        let 白棋集中度 = 0;
        if (白棋位置.length > 1) {
          let 总距离 = 0;
          let 计数 = 0;
          for (let i = 0; i < 白棋位置.length; i++) {
            for (let j = i + 1; j < 白棋位置.length; j++) {
              总距离 += Math.abs(白棋位置[i].行 - 白棋位置[j].行) + Math.abs(白棋位置[i].列 - 白棋位置[j].列);
              计数++;
            }
          }
          白棋集中度 = 总距离 / 计数;
        }

        return this.棋盘.回合 === 白棋
          ? this.棋盘.吃掉黑棋数 * 20 - 白棋集中度 * 5
          : -白棋移动数 * 10 + 白棋边缘得分 * 15 + 黑棋靠近白棋得分 * 5;
      }

      minimax(深度, alpha, beta, 是否最大化) {
        if (深度 === 0 || this.棋盘.检查胜负()) {
          return this.评估();
        }

        const 当前棋方 = this.棋盘.回合;
        let 最佳得分 = 是否最大化 ? -Infinity : Infinity;
        let 最佳移动 = [];
        for (let i = 0; i < this.棋盘.网格.length; i++) {
          if (this.棋盘.网格[i] === 当前棋方) {
            const 移动 = this.棋盘.获取合法移动(i);
            for (const 到 of 移动) {
              const 新棋盘 = this.棋盘.复制();
              const 结果 = 新棋盘.移动棋子(i, 到);
              if (!结果) continue;
              const 旧棋盘 = this.棋盘;
              this.棋盘 = 新棋盘;
              const 分数 = this.minimax(深度 - 1, alpha, beta, !是否最大化);
              this.棋盘 = 旧棋盘;
              if (是否最大化) {
                if (分数 > 最佳得分) {
                  最佳得分 = 分数;
                  最佳移动 = [{ 从: i, 到 }];
                } else if (分数 === 最佳得分) {
                  最佳移动.push({ 从: i, 到 });
                }
                alpha = Math.max(alpha, 最佳得分);
              } else {
                if (分数 < 最佳得分) {
                  最佳得分 = 分数;
                  最佳移动 = [{ 从: i, 到 }];
                } else if (分数 === 最佳得分) {
                  最佳移动.push({ 从: i, 到 });
                }
                beta = Math.min(beta, 最佳得分);
              }
              if (beta <= alpha) {
                break;
              }
            }
          }
        }

        if (深度 === 4) {
          return 最佳移动.length > 0 ? 最佳移动[Math.floor(Math.random() * 最佳移动.length)] : null;
        }
        return 最佳得分;
      }

      获取最佳移动() {
        return this.minimax(4, -Infinity, Infinity, this.棋盘.回合 === 白棋);
      }
    }

    class 渲染器 {
      绘制棋盘(棋盘) {
        上下文.clearRect(0, 0, 画布.width, 画布.height);

        // 绘制网格
        上下文.strokeStyle = '#4B5EAA';
        上下文.lineWidth = 2;
        for (let i = 0; i <= 网格大小; i++) {
          上下文.beginPath();
          上下文.moveTo(i * 格子大小, 0);
          上下文.lineTo(i * 格子大小, 画布.height);
          上下文.stroke();
        }
        for (let i = 0; i <= 网格大小; i++) {
          上下文.beginPath();
          上下文.moveTo(0, i * 格子大小);
          上下文.lineTo(画布.width, i * 格子大小);
          上下文.stroke();
        }

        // 绘制格子编号（1-25）
        上下文.fillStyle = '#666666';
        上下文.font = `${格子大小 / 6}px Georgia`;
        上下文.textAlign = 'right';
        上下文.textBaseline = 'bottom';
        for (let i = 0; i < 网格大小 * 网格大小; i++) {
          const 行 = Math.floor(i / 网格大小);
          const 列 = i % 网格大小;
          上下文.fillText(i + 1, 列 * 格子大小 + 格子大小 - 5, 行 * 格子大小 + 格子大小 - 5);
        }

        // 绘制棋子
        上下文.shadowColor = 'rgba(0, 0, 0, 0.3)';
        上下文.shadowBlur = 8;
        上下文.shadowOffsetX = 3;
        上下文.shadowOffsetY = 3;
        for (let i = 0; i < 棋盘.网格.length; i++) {
          if (棋盘.网格[i]) {
            const 行 = Math.floor(i / 网格大小);
            const 列 = i % 网格大小;
            const x = 列 * 格子大小 + 格子大小 / 2;
            const y = 行 * 格子大小 + 格子大小 / 2;
            const 渐变 = 上下文.createRadialGradient(
              x - 格子大小 / 6, y - 格子大小 / 6, 格子大小 / 10,
              x, y, 格子大小 / 3
            );
            if (棋盘.网格[i] === 白棋) {
              渐变.addColorStop(0, '#F5F5F5'); // 柔和白
              渐变.addColorStop(1, '#E5E7EB'); // 浅灰白
            } else {
              渐变.addColorStop(0, '#333333'); // 深灰黑
              渐变.addColorStop(1, '#1F1F1F'); // 更深灰黑
            }
            上下文.fillStyle = 渐变;
            上下文.beginPath();
            上下文.arc(x, y, 格子大小 / 3, 0, 2 * Math.PI);
            上下文.fill();
            上下文.strokeStyle = 棋盘.网格[i] === 白棋 ? '#000000' : '#D4D4D4'; // 黑棋描边柔和灰白
            上下文.lineWidth = 2;
            上下文.stroke();
          }
        }
        上下文.shadowColor = 'transparent';

        // 高亮选中棋子
        if (棋盘.选中棋子 !== null) {
          const 行 = Math.floor(棋盘.选中棋子 / 网格大小);
          const 列 = 棋盘.选中棋子 % 网格大小;
          上下文.strokeStyle = '#FFFF00';
          上下文.lineWidth = 5;
          上下文.beginPath();
          上下文.arc(
            列 * 格子大小 + 格子大小 / 2,
            行 * 格子大小 + 格子大小 / 2,
            格子大小 / 3,
            0,
            2 * Math.PI
          );
          上下文.stroke();

          // 高亮合法移动
          上下文.fillStyle = 'rgba(50, 205, 50, 0.4)';
          for (const 移动位置 of 棋盘.获取合法移动(棋盘.选中棋子)) {
            const 移动行 = Math.floor(移动位置 / 网格大小);
            const 移动列 = 移动位置 % 网格大小;
            上下文.fillRect(移动列 * 格子大小, 移动行 * 格子大小, 格子大小, 格子大小);
          }
        }

        // 高亮最后移动
        if (棋盘.最后移动) {
          const { 从, 到 } = 棋盘.最后移动;
          const 从行 = Math.floor(从 / 网格大小);
          const 从列 = 从 % 网格大小;
          const 到行 = Math.floor(到 / 网格大小);
          const 到列 = 到 % 网格大小;
          上下文.strokeStyle = 'green';
          上下文.lineWidth = 2;
          上下文.setLineDash([5, 5]);
          上下文.strokeRect(从列 * 格子大小, 从行 * 格子大小, 格子大小, 格子大小);
          上下文.strokeRect(到列 * 格子大小, 到行 * 格子大小, 格子大小, 格子大小);
          上下文.setLineDash([]);
        }
      }

      动画移动(棋盘, 从, 到, 是否吃子, 回调) {
        const 从行 = Math.floor(从 / 网格大小);
        const 从列 = 从 % 网格大小;
        const 到行 = Math.floor(到 / 网格大小);
        const 到列 = 到 % 网格大小;
        let t = 0;
        const 持续时间 = 是否吃子 ? 500 : 300;
        const 开始X = 从列 * 格子大小 + 格子大小 / 2;
        const 开始Y = 从行 * 格子大小 + 格子大小 / 2;
        const 结束X = 到列 * 格子大小 + 格子大小 / 2;
        const 结束Y = 到行 * 格子大小 + 格子大小 / 2;

        const 动画 = () => {
          t += 16 / 持续时间;
          if (t >= 1) {
            this.绘制棋盘(棋盘);
            播放音效(是否吃子 ? 440 : 300, 是否吃子 ? 0.1 : 0.05);
            回调();
            return;
          }

          this.绘制棋盘(棋盘);
          const x = 开始X + (结束X - 开始X) * t;
          const y = 开始Y + (结束Y - 开始Y) * t;
          const 缩放 = 是否吃子
            ? (t < 0.5 ? 1 + 0.2 * t * 2 : 1.2 - 0.2 * (t - 0.5) * 2)
            : (t < 0.5 ? 1 + 0.1 * t * 2 : 1.1 - 0.1 * (t - 0.5) * 2);
          const 渐变 = 上下文.createRadialGradient(
            x - 格子大小 / 6, y - 格子大小 / 6, 格子大小 / 10,
            x, y, (格子大小 / 3) * 缩放
          );
          const 棋子颜色 = 棋盘.网格[到] || 棋盘.网格[从];
          if (棋子颜色 === 白棋) {
            渐变.addColorStop(0, '#F5F5F5');
            渐变.addColorStop(1, '#E5E7EB');
          } else {
            渐变.addColorStop(0, '#333333');
            渐变.addColorStop(1, '#1F1F1F');
          }
          上下文.fillStyle = 渐变;
          上下文.shadowColor = 'rgba(0, 0, 0, 0.3)';
          上下文.shadowBlur = 8;
          上下文.shadowOffsetX = 3;
          上下文.shadowOffsetY = 3;
          上下文.beginPath();
          上下文.arc(x, y, (格子大小 / 3) * 缩放, 0, 2 * Math.PI);
          上下文.fill();
          上下文.strokeStyle = 棋子颜色 === 白棋 ? '#000000' : '#D4D4D4';
          上下文.lineWidth = 2;
          上下文.stroke();
          上下文.shadowColor = 'transparent';

          requestAnimationFrame(动画);
        };

        requestAnimationFrame(动画);
      }
    }

    class 游戏 {
      constructor() {
        this.棋盘 = new 棋盘();
        this.渲染器 = new 渲染器();
        this.AI = new AI(this.棋盘);
        this.玩家棋方 = null;
        this.AI移动中 = false;
        this.棋盘.初始化();
        this.渲染器.绘制棋盘(this.棋盘);
        this.更新状态();
      }

      更新状态() {
        if (this.玩家棋方 === null) {
          状态.textContent = '请选择执白棋或执黑棋';
          状态.className = '';
        } else {
          const 结果 = this.棋盘.检查胜负();
          if (结果) {
            状态.textContent = 结果;
            状态.className = '胜负提示';
          } else {
            状态.textContent = `您执${this.玩家棋方 === 白棋 ? '白棋' : '黑棋'} | 轮到：${this.棋盘.回合 === 白棋 ? '白棋' : '黑棋'} | 吃掉黑棋数：${this.棋盘.吃掉黑棋数}`;
            状态.className = `回合-${this.棋盘.回合 === 白棋 ? '白棋' : '黑棋'}`;
          }
        }
      }

      选择棋方(棋方) {
        this.玩家棋方 = 棋方;
        执白棋按钮.disabled = true;
        执黑棋按钮.disabled = true;
        this.AI移动中 = false;
        this.棋盘.初始化();
        this.AI = new AI(this.棋盘);
        this.渲染器.绘制棋盘(this.棋盘);
        this.更新状态();
        if (this.棋盘.回合 !== this.玩家棋方) {
          this.AI移动();
        }
      }

      AI移动() {
        if (this.AI移动中) return;
        this.AI移动中 = true;
        const 移动 = this.AI.获取最佳移动();
        if (移动 && 移动.从 !== undefined && 移动.到 !== undefined) {
          setTimeout(() => {
            this.棋盘.选中棋子 = 移动.从;
            this.渲染器.绘制棋盘(this.棋盘);
            setTimeout(() => {
              const 结果 = this.棋盘.移动棋子(移动.从, 移动.到);
              if (结果) {
                const { 从, 到, 是否吃子 } = 结果;
                this.渲染器.动画移动(this.棋盘, 从, 到, 是否吃子, () => {
                  this.棋盘.选中棋子 = null;
                  const 结果 = this.棋盘.检查胜负();
                  if (结果) {
                    状态.textContent = 结果;
                    状态.className = '胜负提示';
                    画布.removeEventListener('click', this.点击处理器);
                  } else {
                    this.更新状态();
                    if (this.棋盘.回合 !== this.玩家棋方) {
                      this.AI移动();
                    }
                  }
                  this.AI移动中 = false;
                  this.渲染器.绘制棋盘(this.棋盘);
                });
              } else {
                this.AI移动中 = false;
                this.棋盘.选中棋子 = null;
                this.渲染器.绘制棋盘(this.棋盘);
              }
            }, 500);
          }, 500);
        } else {
          this.AI移动中 = false;
          this.渲染器.绘制棋盘(this.棋盘);
        }
      }

      处理点击(x, y) {
        if (this.玩家棋方 === null || this.AI移动中) return;
        if (this.棋盘.回合 !== this.玩家棋方) return;

        const 行 = Math.floor(y / 格子大小);
        const 列 = Math.floor(x / 格子大小);
        const 位置 = 行 * 网格大小 + 列;

        if (this.棋盘.选中棋子 === null) {
          if (this.棋盘.网格[位置] === this.棋盘.回合) {
            this.棋盘.选中棋子 = 位置;
            this.渲染器.绘制棋盘(this.棋盘);
          }
        } else {
          const 移动 = this.棋盘.获取合法移动(this.棋盘.选中棋子);
          if (移动.includes(位置)) {
            const 结果 = this.棋盘.移动棋子(this.棋盘.选中棋子, 位置);
            if (结果) {
              const { 从, 到, 是否吃子 } = 结果;
              this.渲染器.动画移动(this.棋盘, 从, 到, 是否吃子, () => {
                this.棋盘.选中棋子 = null;
                const 结果 = this.棋盘.检查胜负();
                if (结果) {
                  状态.textContent = 结果;
                  状态.className = '胜负提示';
                  画布.removeEventListener('click', this.点击处理器);
                } else {
                  this.更新状态();
                  if (this.棋盘.回合 !== this.玩家棋方) {
                    this.AI移动();
                  }
                }
                this.渲染器.绘制棋盘(this.棋盘);
              });
            } else {
              this.棋盘.选中棋子 = null;
              this.渲染器.绘制棋盘(this.棋盘);
            }
          } else {
            this.棋盘.选中棋子 = null;
            this.渲染器.绘制棋盘(this.棋盘);
          }
        }
      }

      重置() {
        this.玩家棋方 = null;
        this.AI移动中 = false;
        执白棋按钮.disabled = false;
        执黑棋按钮.disabled = false;
        this.棋盘.初始化();
        this.AI = new AI(this.棋盘);
        画布.addEventListener('click', this.点击处理器);
        this.渲染器.绘制棋盘(this.棋盘);
        this.更新状态();
      }
    }

    const 游戏实例 = new 游戏();
    游戏实例.点击处理器 = (e) => {
      const 矩形 = 画布.getBoundingClientRect();
      const x = e.clientX - 矩形.left;
      const y = e.clientY - 矩形.top;
      游戏实例.处理点击(x, y);
    };
    画布.addEventListener('click', 游戏实例.点击处理器);
    重置按钮.addEventListener('click', () => 游戏实例.重置());
    执白棋按钮.addEventListener('click', () => 游戏实例.选择棋方(白棋));
    执黑棋按钮.addEventListener('click', () => 游戏实例.选择棋方(黑棋));

    // 响应式画布尺寸
    function 调整画布大小() {
      if (window.innerWidth < 600) {
        画布.width = 300;
        画布.height = 300;
      } else if (window.innerWidth < 800) {
        画布.width = 400;
        画布.height = 400;
      } else {
        画布.width = 500;
        画布.height = 500;
      }
      格子大小 = 画布.width / 网格大小;
      游戏实例.渲染器.绘制棋盘(游戏实例.棋盘);
    }
    window.addEventListener('resize', 调整画布大小);
    调整画布大小();
  </script>
</body>
</html>